# Configure paths

FLYWHEEL_BASE=/flywheel/v0
OUTPUT_DIR=$FLYWHEEL_BASE/output
INPUT_DIR=$FLYWHEEL_BASE/input
CONFIG_FILE=$FLYWHEEL_BASE/config.json

# Parse configuration
if [[ -f $CONFIG_FILE ]]; then
  eval $(jq -r '.config | to_entries[] | "config_\(.key)=\"\(.value)\""' $CONFIG_FILE)
else
  CONFIG_FILE=$FLYWHEEL_BASE/manifest.json
  eval $(jq -r '.config | to_entries[] | "config_\(.key)=\(.value.default)"' $CONFIG_FILE)
fi


# The input to this Gear can be either a zip, a tgz, or a mounted volume
# containing DICOMs. Below we handle all those cases.

input_file=$(find $INPUT_DIR/* -not -path '*/\.*' -type f | head -1)
dicom_input=''

if [[ -z "$input_file" ]] ; then
  echo -e "$CONTAINER No input file was found!"
  exit 1
fi

# Prepare inputs: unzip, gunzip, or uncompressed
if [[ "$input_file" == *.zip ]] ; then

  echo "$CONTAINER  Unzipping $input_file"
  unzip -q "$input_file" -d $INPUT_DIR

  # Find unzipped directory in input dir
  dicom_input=$(find $INPUT_DIR/* -not -path '*/\.*' -type d | head -1)

  # If there is no unzipped directory, check for PAR/REC files
  if [[ -z "$dicom_input" ]]; then
      dicom_input=$(find $INPUT_DIR/* -not -path '*/\.*' -type f -name "*.par" -o -name "*.PAR" | head -1)
  fi

  # Zip bomb: Set dicom_input to INPUT_DIR
  if [[ -z "$dicom_input" ]]; then
    dicom_input=$INPUT_DIR
  fi

elif [[ "$input_file" == *.gz ]]; then
  cd $INPUT_DIR
  echo "$CONTAINER  Gunzipping $input_file"
  gunzip -q "$input_file"
  dicom_input=$(basename "$input_file" .gz)

else
  # Assume a directory containing dicoms was mounted in and pass it on 
  # (local docker execution)
  # or single .dcm file
  
  dicom_input=$INPUT_DIR
  cp $input_file $INPUT_DIR 
fi


##############################################################################
# Run the storescu algorithm passing ENV vars with config

storescu --scan-directories -aet flywheel \
  -aec ${config_called_ae} \
  ${config_destination} \
  ${config_port} \
  ${dicom_input} \



