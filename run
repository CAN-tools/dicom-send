#!/bin/bash

# Configure paths

FLYWHEEL_BASE=/flywheel/v0
OUTPUT_DIR=$FLYWHEEL_BASE/output
INPUT_DIR=$FLYWHEEL_BASE/input
CONFIG_FILE=$FLYWHEEL_BASE/config.json

##############################################################################
# Parse configuration

# If the config file does not exist (i.e., local run) then parse the config
# options and values from the manifest. Those variables can be found in the
# manifest.json file within the `config` map.


function parse_config {
  # If config.json exists, then we parse config file  Otherwise we parse
  # manifest.json.

  CONFIG_FILE=$FLYWHEEL_BASE/config.json
  MANIFEST_FILE=$FLYWHEEL_BASE/manifest.json

  if [[ -f $CONFIG_FILE ]]; then
    echo -e "$(cat $CONFIG_FILE | jq -r '.config.'$1)"
  else
    CONFIG_FILE=$MANIFEST_FILE
    echo -e "$(cat $MANIFEST_FILE | jq -r '.config.'$1'.default')"
  fi
}

function parse_config_file {
  CONFIG_FILE=$FLYWHEEL_BASE/config.json

  if [[ -f $CONFIG_FILE ]]; then
    echo -e "$(cat $CONFIG_FILE | jq -r $1)"
  fi
}

config_called_ae="$(parse_config 'called_ae')"
config_destination="$(parse_config 'destination')"
config_port="$(parse_config 'port')"
config_calling_ae="$(parse_config 'calling_ae')"

# The input to this Gear can be either a zip, a tgz, or a mounted volume
# containing DICOMs. Below we handle all those cases.

input_file=$(find $INPUT_DIR/* -not -path '*/\.*' -type f | head -1)
dicom_input=''

if [[  -z "$input_file" ]] ; then
  # Get Session ID
  config_session_id="$(parse_config_file '.destination.id')"
  api_key="$(parse_config_file '.inputs.api_key.key')"
  echo -e "$CONTAINER No input file was found! Sending all dicoms in session"
  python download_dicoms.py --api-key "${api_key}" --session "${config_session_id}" --input_dir "${INPUT_DIR}/file"
fi

for input_file in $INPUT_DIR/file/*; do
  # Prepare inputs: unzip, gunzip, or uncompressed
  if [[ "$input_file" == *.zip ]] ; then

    echo "$CONTAINER  Unzipping $input_file"
    dicom_input=$INPUT_DIR/$(unzip -Z -1 "${input_file}" | head -1)

    # If zip bomb, place the contents into its own folder named
    # after the file's basename
    tempdir=$(mktemp -d)
    unzip -q "$input_file" -d $tempdir
    if [ $(ls $tempdir | wc -l) = 1 ]; then
      mv $tempdir/* $INPUT_DIR
      rmdir $tempdir
      dicom_input=$INPUT_DIR/$(unzip -Z -1 "${input_file}" | head -1)
    else
      dicom_input=${INPUT_DIR}/$(echo "$input_file" | cut -f 1 -d '.')
      mv $tempdir "$dicom_input"
    fi

  elif [[ "$input_file" == *.gz ]]; then
    cd $INPUT_DIR
    echo "$CONTAINER  Gunzipping $input_file"
    gunzip -q "$input_file"
    dicom_input=$(basename "$input_file" .gz)

  else
    # Assume a directory containing dicoms was mounted in and pass it on
    # (local docker execution)
    # or single .dcm file

    dicom_input=$INPUT_DIR
    cp -a $input_file $INPUT_DIR
  fi


  ##############################################################################
  # Run the storescu algorithm passing ENV vars with config

  storescu -v --scan-directories -aet "${config_calling_ae}" \
    -aec "${config_called_ae}" \
    "${config_destination}" \
    "${config_port}" \
    "${dicom_input}" \

  if [ $? -eq 0 ]; then
    echo OK
  else
    echo "FAIL: $input_file"
    exit 1
  fi

done
