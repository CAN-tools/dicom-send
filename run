#!/bin/bash

# Configure paths

FLYWHEEL_BASE=/flywheel/v0
OUTPUT_DIR=$FLYWHEEL_BASE/output
INPUT_DIR=$FLYWHEEL_BASE/input
CONFIG_FILE=$FLYWHEEL_BASE/config.json

##############################################################################
# Parse configuration

# If the config file does not exist (i.e., local run) then parse the config
# options and values from the manifest. Those variables can be found in the
# manifest.json file within the `config` map.


function parse_config {
  # If config.json exists, then we parse config file  Otherwise we parse
  # manifest.json.

  CONFIG_FILE=$FLYWHEEL_BASE/config.json
  MANIFEST_FILE=$FLYWHEEL_BASE/manifest.json

  if [[ -f $CONFIG_FILE ]]; then
    echo -e "$(cat $CONFIG_FILE | jq -r '.config.'$1)"
  else
    CONFIG_FILE=$MANIFEST_FILE
    echo -e "$(cat $MANIFEST_FILE | jq -r '.config.'$1'.default')"
  fi
}

config_called_ae="$(parse_config 'called_ae')"
config_destination="$(parse_config 'destination')"
config_port="$(parse_config 'port')"
config_calling_ae="$(parse_config 'calling_ae')"


# The input to this Gear can be either a zip, a tgz, or a mounted volume
# containing DICOMs. Below we handle all those cases.

input_file=$(find $INPUT_DIR/* -not -path '*/\.*' -type f | head -1)
dicom_input=''

if [[ -z "$input_file" ]] ; then
  echo -e "$CONTAINER No input file was found!"
  exit 1
fi

# Prepare inputs: unzip, gunzip, or uncompressed
if [[ "$input_file" == *.zip ]] ; then

  echo "$CONTAINER  Unzipping $input_file"
  unzip -q "$input_file" -d $INPUT_DIR

  # Find unzipped directory in input dir
  dicom_input=$(find $INPUT_DIR/* -not -path '*/\.*' -type d | head -1)

  # Zip bomb: Set dicom_input to INPUT_DIR
  if [[ -z "$dicom_input" ]]; then
    dicom_input=$INPUT_DIR
  fi

elif [[ "$input_file" == *.gz ]]; then
  cd $INPUT_DIR
  echo "$CONTAINER  Gunzipping $input_file"
  gunzip -q "$input_file"
  dicom_input=$(basename "$input_file" .gz)

else
  # Assume a directory containing dicoms was mounted in and pass it on
  # (local docker execution)
  # or single .dcm file

  dicom_input=$INPUT_DIR
  cp -a $input_file $INPUT_DIR
fi


##############################################################################
# Run the storescu algorithm passing ENV vars with config

storescu -v --scan-directories -aet "${config_calling_ae}" \
  -aec "${config_called_ae}" \
  "${config_destination}" \
  "${config_port}" \
  "${dicom_input}" \
